/**
 * CelestialWizardry
 * Master build file
 *
 * @author PizzAna
 */

buildscript {

    // Add dependencies for the build script
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
    }
}

// Add dependency repositories
repositories {
    maven {
        name = "chickenbones"
        url = "http://chickenbones.net/maven/"
    }
}

apply plugin: 'forge'

// http://maven.apache.org/guides/mini/guide-naming-conventions.html
group 'celestialwizardry'

// The name used in final archive artifacts
archivesBaseName = "CelestialWizardry"

// The main property file
ext.configFile = file "build.properties"

// Load the main property file. It shall from now be referenced as simply config or project.config
configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

ext.mod_version = "${config.major_number}.${config.minor_number}.${config.patch_number}"

// Add code dependencies
dependencies {
    /**
     * You may put jars on which you depend on in ./libs
     * or you may define them like so:
     *
     * compile "some.group:artifact:version:classifier"
     * compile "some.group:artifact:version"
     *
     * Real examples:
     *
     * compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // Adds BuildCraft to the development environment
     * compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // Adds ejml to the development environment
     *
     * For more info:
     *
     * http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
     * http://www.gradle.org/docs/current/userguide/dependency_management.html
     */
}

// Find and set the version info from git for the build
task buildInfo {

    // Run the command to get the git revision
    def cmd = "git rev-parse --short HEAD"
    def run = cmd.execute()
    run.waitFor()

    // Set the revision depending on the result of command execution
    if (run.exitValue() == 0)
    {
        ext.revision = run.text.trim()
    }
    else
    {
        ext.revision = "NULL"
    }
}

// Sets the version for the mod
version = "${mod_version}"

// Set the version for the mod
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    if (!Boolean.valueOf((String) props['release']))
    {
        version = "${project.buildInfo.revision}"
    }
}
else
{
    version = "${project.buildInfo.revision}"
}

// Print out the minecraft forge version
println config.mc_version + "-" + config.forge_version

// Setup the forge minecraft plugin data. Specify the preferred forge/minecraft version and assets directory here
minecraft {
    version = config.mc_version + "-" + config.forge_version
    assetDir = 'run/assets'

    replaceIn "reference/Reference.java"
    if (project.hasProperty("CelestialWizardry.release") &&
            new File(project.property("CelestialWizardry.release")).exists())
    {

        // Load the private property file if one is found
        Properties props = new Properties()
        props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

        if (Boolean.valueOf((String) props['release']))
        {
            replace "@FINGERPRINT@", props['signature']
        }
        else
        {
            replace "@FINGERPRINT@", "dev"
        }
    }

    replaceIn "reference/Version.java"
    replace "@VERSION@", project.version
}

processResources {

    // This will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mc_version", config.mc_version
    inputs.property "baubles_version", config.baubles_version

    // Replace properties in info files
    from(sourceSets.main.resources.srcDirs) {

        // Include only info files
        include '*.info'

        // Replace version, mc_vrsion and baubles_version
        expand 'version': project.version, 'mc_version': config.mc_version, 'baubles_version': config.baubles_version
    }

    // Copy everything excluding info files
    from(sourceSets.main.resources.srcDirs) {

        // Exclude info files
        exclude '*.info'
    }
}

// Set the version for archive names
version = "${project.minecraft.version}-${project.version}"

// Set the common manifest for archives
def commonManifest = {
    attributes 'FMLCorePlugin': 'celestialwizardry.codechicken.core.launch.DepLoader'
    attributes 'FMLCorePluginContainsFMLMod': 'true'
}

// Make the universal jar
jar {
    manifest commonManifest
}

// Make the source jar
task sourceJar(type: Jar) {
    from sourceSets.main.java
    classifier = "src"
}

// Make the api jar
task apiJar(type: Jar) {
    from(sourceSets.main.java) {

        // Include only the api package
        include 'celestialwizardry/api/*'
    }

    classifier = "api"
}

// Make the deobsfucated developer jar
task devJar(type: Jar) {
    from sourceSets.main.output
    classifier = "deobf"
    manifest commonManifest
}

// Tell the archive system about the extra archives
artifacts {
    archives sourceJar
    archives apiJar
    archives devJar
}

// Set the information for signing the jar
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    ext.keystore_location = file(props['keystore_location'])
    ext.keystore_user_alias = props['keystore_alias']
    ext.keystore_user_password = props['keystore_password']

    println "Valid jar signing properties found"

}
else
{
    ext.keystore_location = "."
    ext.keystore_user_alias = ""
    ext.keystore_user_password = ""
}

// Sign the final jar
task signJar(dependsOn: "build") {

    // This will ensure that this task is redone when the some of these properties change.
    inputs.file jar.getArchivePath()
    inputs.file keystore_location
    inputs.property "keystore_user_alias", keystore_user_alias
    inputs.property "keystore_user_password", keystore_user_password
    outputs.file jar.getArchivePath()

    // Only sign the jar if the keystore exists
    onlyIf {
        return keystore_location != "."
    }

    println "Path to archive: " + jar.getArchivePath()
    // println jar.getArchivePath()

    // Sign the jar.
    doLast {
        ant.signjar(
                destDir: jar.destinationDir,
                jar: jar.getArchivePath(),
                keystore: keystore_location,
                alias: keystore_user_alias,
                storepass: keystore_user_password,
                keypass: keystore_user_password
        )
    }
}

// Set the information for releasing the jar
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    ext.release_location = props['release_location']

    ext.release_location = release_location.replace("{MC}", project.minecraft.version).
            replace("{VERSION}", "${project.version}".replace("${config.mc_version}-", ""))

    println "Valid jar uploading properties found"

}
else
{
    ext.release_location = "."
}

// Increments the build number
task incrementBuildNumber(dependsOn: "signJar") {

    // Print the version information
    println "CelestialWizardry: version ${version}".replace("${config.mc_version}-", "") +
                    " build ${config.build_number}"

    // Check if this is final version
    if (project.hasProperty("CelestialWizardry.release") &&
            new File(project.property("CelestialWizardry.release")).exists())
    {

        // Load the private property file if one is found
        Properties props = new Properties()
        props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

        if (Boolean.valueOf((String) props['release']))
        {
            if (!Boolean.valueOf((String) props['final_patch']) && !Boolean.valueOf((String) props['final_minor']))
            {

                ant.propertyfile(file: 'build.properties') {
                    entry(key: 'patch_number', type: 'int', operation: '+', value: '1')
                }

            }
            else
            {
                if (Boolean.valueOf((String) props['final_minor']))
                {

                    // Print this is the final build of current major version
                    println "Final build of version ${config.major_number}"

                    ant.propertyfile(file: 'build.properties') {
                        entry(key: 'patch_number', type: 'int', operation: '=', value: '0')
                        entry(key: 'minor_number', type: 'int', operation: '=', value: '0')
                        entry(key: 'major_number', type: 'int', operation: '+', value: '1')
                    }

                    ant.propertyfile(file: 'private.properties') {
                        entry(key: 'final_patch', operation: '=', value: 'false')
                        entry(key: 'final_minor', operation: '=', value: 'false')
                    }
                }
                else if (Boolean.valueOf((String) props['final_patch']))
                {

                    // Print this is the final build of current minor version
                    println "Final build of version ${config.minor_number}"

                    ant.propertyfile(file: 'build.properties') {
                        entry(key: 'patch_number', type: 'int', operation: '=', value: '0')
                        entry(key: 'minor_number', type: 'int', operation: '+', value: '1')
                    }

                    ant.propertyfile(file: 'private.properties') {
                        entry(key: 'final_patch', operation: '=', value: 'false')
                    }
                }
            }
        }
    }

    doLast {
        ant.propertyfile(file: 'build.properties') {
            entry(key: 'build_number', type: 'int', operation: '+', value: '1')
        }
    }
}

task release(type: Copy, dependsOn: "incrementBuildNumber") {
    from(project.tasks.jar.destinationDir) {
        include "*-${project.version}*"
    }
    into project.file(project.release_location)

    println "Release location: " + project.release_location

    eachFile {file ->
        logger.info "copying ${file}"
    }

    // Copy only if the release location isn't empty
    onlyIf {
        return project.release_location != "."
    }
}
