/**
 * CelestialWizardry
 * Master build file
 *
 * @author PizzAna
 */

buildscript {

    // Add dependencies for the build script
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
    }
}

// Add dependency repositories
repositories {
    maven {
        name = "chickenbones"
        url = "http://chickenbones.net/maven/"
    }
}

apply plugin: 'forge'

// http://maven.apache.org/guides/mini/guide-naming-conventions.html
group 'celestialwizardry'

// The name used in final archive artifacts
archivesBaseName = "CelestialWizardry"

// The main property file
ext.configFile = file "build.properties"

// Load the main property file. It shall from now be referenced as simply config or project.config
configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

// Add code dependencies
dependencies {
    /**
     * You may put jars on which you depend on in ./libs
     * or you may define them like so:
     *
     * compile "some.group:artifact:version:classifier"
     * compile "some.group:artifact:version"
     *
     * Real examples:
     *
     * compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // Adds BuildCraft to the development environment
     * compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // Adds ejml to the development environment
     *
     * For more info:
     *
     * http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
     * http://www.gradle.org/docs/current/userguide/dependency_management.html
     */
}

// Find and set the version info from git for the build
task buildInfo {

    // Run the command to get the git revision
    def cmd = "git rev-parse --short HEAD"
    def run = cmd.execute()
    run.waitFor()

    // Set the revision depending on the result of command execution
    if (run.exitValue() == 0)
    {
        ext.revision = run.text.trim()
    }
    else
    {
        ext.revision = "NULL"
    }
}

version = "${config.major_number}.${config.minor_number}.${config.patch_number}"

// Set the version for the mod
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    if (Boolean.valueOf((String) props['release']) && !Boolean.valueOf((String) props['pre_release']))
    {
        version = "${config.major_number}.${config.minor_number}.${config.patch_number}"
        ext.isRelease = true
    }
    else if (Boolean.valueOf((String) props['pre_release']) ||
            (Boolean.valueOf((String) props['release']) && Boolean.valueOf((String) props['pre_release'])))
    {
        version =
                "${config.major_number}.${config.minor_number}.${config.patch_number}-${config.pre_release_prefix}" +
                        ".${config.pre_release_number}"
        ext.isRelease = true
    }
    else
    {
        version = "${project.buildInfo.revision}"
        ext.isRelease = false
    }
}
else
{
    version = "${project.buildInfo.revision}"
    ext.isRelease = false
}

// Print out the minecraft forge version
println config.mc_version + "-" + config.forge_version

// Setup the forge minecraft plugin data. Specify the preferred forge/minecraft version and assets directory here
minecraft {
    version = config.mc_version + "-" + config.forge_version
    assetDir = 'run/assets'

    replaceIn "reference/Reference.java"
    if (project.hasProperty("CelestialWizardry.release") &&
            new File(project.property("CelestialWizardry.release")).exists())
    {

        // Load the private property file if one is found
        Properties props = new Properties()
        props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

        if (Boolean.valueOf((String) props['release']) || Boolean.valueOf((String) props['pre_release']))
        {
            replace "@FINGERPRINT@", props['signature']
        }
        else
        {
            replace "@FINGERPRINT@", "dev"
        }
    }

    replaceIn "reference/Version.java"
    replace "@VERSION@", project.version

    replaceIn "api/CWApi.java"
    if (project.hasProperty("CelestialWizardry.release") &&
            new File(project.property("CelestialWizardry.release")).exists())
    {

        // Load the private property file if one is found
        Properties props = new Properties()
        props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

        if (Boolean.valueOf((String) props['release']) && !Boolean.valueOf((String) props['pre_release']))
        {
            replace "@API_VERSION@", project.version.replace(".${config.patch_number}", "")
        }
        else if (Boolean.valueOf((String) props['pre_release']) ||
                (Boolean.valueOf((String) props['release']) && Boolean.valueOf((String) props['pre_release'])))
        {
            replace "@API_VERSION@", project.version.replace(".${config.patch_number}", "")
        }
        else
        {
            replace "@API_VERSION@", "dev"
        }
    }
}

processResources {

    // This will ensure that this task is redone when the versions or Baubles root directory change.
    inputs.property "version", project.version
    inputs.property "mc_version", config.mc_version
    inputs.property "baubles_version", config.baubles_version
    inputs.property "baubles_root", config.baubles_root

    // Replace properties in info files
    from(sourceSets.main.resources.srcDirs) {

        // Include only info files
        include '*.info'

        // Replace version, mc_vrsion and baubles_version
        expand 'version': project.version, 'mc_version': config.mc_version, 'baubles_version': config.baubles_version,
               'baubles_root': config.baubles_root
    }

    // Copy everything excluding info files
    from(sourceSets.main.resources.srcDirs) {

        // Exclude info files
        exclude '*.info'
    }
}

// Set the version for archive names
version = "${project.minecraft.version}-${project.version}"

// Set the common manifest for archives
def commonManifest = {
    attributes 'FMLCorePlugin': 'celestialwizardry.codechicken.core.launch.DepLoader'
    attributes 'FMLCorePluginContainsFMLMod': 'true'
}

// Make the universal jar
jar {
    manifest commonManifest
}

// Make the source jar
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
    classifier = "src"
}

// Make the api jar
task apiJar(type: Jar) {
    from(sourceSets.main.allSource) {

        // Include only the api package
        include 'celestialwizardry/api/*'
    }

    classifier = "api"
}

// Make the deobsfucated developer jar
task deobfJar(type: Jar) {
    from sourceSets.main.output
    classifier = "deobf"
    manifest commonManifest
}

// Tell the archive system about the extra archives
artifacts {
    archives apiJar
    archives deobfJar
    archives sourceJar
}

ext.baubles_file = "Baubles-deobf-${config.mc_version}-${config.baubles_version}.jar"
ext.baubles_url = "${config.baubles_root}${project.baubles_file}"
ext.temp_dir = "./temp/"
ext.baubles_temp = "${project.temp_dir}${project.baubles_file}"

// Download baubles from azanor's mirror
task getBaubles(dependsOn: "extractUserDev") {
    ant.mkdir(dir: project.temp_dir)
    ant.get(src: project.baubles_url, dest: project.baubles_temp)
}

// Copy baubles into libs folder
task copyBaubles(type: Copy, dependsOn: "getBaubles") {
    from project.baubles_temp
    into file("./libs/")

    doLast {
        // Delete the temp dir
        ant.delete(dir: project.temp_dir)
    }
}

// Make getting baubles dependency for setting up the workspace
tasks.setupDevWorkspace.dependsOn copyBaubles
tasks.setupDecompWorkspace.dependsOn copyBaubles

// Set the information for signing the jar
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    ext.keystore_location = file(props['keystore_location'])
    ext.keystore_user_alias = props['keystore_alias']
    ext.keystore_user_password = props['keystore_password']

    println "Valid jar signing properties found"

}
else
{
    ext.keystore_location = "."
    ext.keystore_user_alias = ""
    ext.keystore_user_password = ""
}

// Sign the final jar
task signJar(dependsOn: "build") {

    // This will ensure that this task is redone when the some of these properties change.
    inputs.file jar.getArchivePath()
    inputs.file keystore_location
    inputs.property "keystore_user_alias", keystore_user_alias
    inputs.property "keystore_user_password", keystore_user_password
    outputs.file jar.getArchivePath()

    // Only sign the jar if the keystore exists
    onlyIf {
        return keystore_location != "."
    }

    println "Path to archive: " + jar.getArchivePath()

    // Sign the jar
    doLast {
        ant.signjar(
                destDir: jar.destinationDir,
                jar: jar.getArchivePath(),
                keystore: keystore_location,
                alias: keystore_user_alias,
                storepass: keystore_user_password,
                keypass: keystore_user_password
        )
    }
}

// Set the information for releasing the jar
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    ext.release_location = props['release_location']

    ext.release_location = release_location.replace("{MC}", project.minecraft.version).
            replace("{VERSION}", "${project.version}".replace("${config.mc_version}-", ""))

    println "Valid jar uploading properties found"

}
else
{
    ext.release_location = "."
}

// Increments the build number
task incrementBuildNumber(dependsOn: "signJar") {

    // This will ensure that this task is redone when the versions change.
    inputs.property "version", project.version

    // Print the version information
    println "CelestialWizardry: version ${version}".replace("${config.mc_version}-", "") +
                    " build ${config.build_number}"

    // These are here in doLast so they aren't called when you set up workspace
    doLast {

        // Check if this is final version
        if (project.hasProperty("CelestialWizardry.release") &&
                new File(project.property("CelestialWizardry.release")).exists())
        {

            // Load the private property file if one is found
            Properties props = new Properties()
            props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

            if (Boolean.valueOf((String) props['release']) && !Boolean.valueOf((String) props['pre_release']))
            {
                if (!Boolean.valueOf((String) props['final_patch']) && !Boolean.valueOf((String) props['final_minor']))
                {
                    ant.propertyfile(file: 'build.properties') {
                        entry(key: 'patch_number', type: 'int', operation: '+', value: '1')
                    }
                }
                else
                {
                    if (Boolean.valueOf((String) props['final_minor']))
                    {
                        // Print this is the final build of current major version
                        println "Final build of version ${config.major_number}"

                        ant.propertyfile(file: 'build.properties') {
                            entry(key: 'patch_number', type: 'int', operation: '=', value: '0')
                            entry(key: 'minor_number', type: 'int', operation: '=', value: '0')
                            entry(key: 'major_number', type: 'int', operation: '+', value: '1')
                        }

                        ant.propertyfile(file: 'private.properties') {
                            entry(key: 'final_patch', operation: '=', value: 'false')
                            entry(key: 'final_minor', operation: '=', value: 'false')
                        }
                    }
                    else if (Boolean.valueOf((String) props['final_patch']))
                    {
                        // Print this is the final build of current minor version
                        println "Final build of version ${config.minor_number}"

                        ant.propertyfile(file: 'build.properties') {
                            entry(key: 'patch_number', type: 'int', operation: '=', value: '0')
                            entry(key: 'minor_number', type: 'int', operation: '+', value: '1')
                        }

                        ant.propertyfile(file: 'private.properties') {
                            entry(key: 'final_patch', operation: '=', value: 'false')
                        }
                    }
                }
            }
            else if (Boolean.valueOf((String) props['pre_release']) ||
                    (Boolean.valueOf((String) props['release']) && Boolean.valueOf((String) props['pre_release'])))
            {
                ant.propertyfile(file: 'build.properties') {
                    entry(key: 'pre_release_number', type: 'int', operation: '+', value: '1')
                }
            }
        }

        ant.propertyfile(file: 'build.properties') {
            entry(key: 'build_number', type: 'int', operation: '+', value: '1')
        }

        // The new property file
        ext.newFile = file "build.properties"

        // Load the new property file. It shall from now be referenced as simply new_config or project.new_config
        newFile.withReader {
            def prop = new Properties()
            prop.load(it)
            project.ext.new_config = new ConfigSlurper().parse prop
        }

        println "Next release: ${new_config.major_number}.${new_config.minor_number}.${new_config.patch_number} build" +
                        " ${new_config.build_number} if not pre-release"
    }
}

task release(type: Copy, dependsOn: "incrementBuildNumber") {
    from(project.tasks.jar.destinationDir) {
        include "*-${project.version}*"
    }
    into project.file(project.release_location)

    println "Release location: " + project.release_location

    eachFile {file ->
        logger.info "copying ${file}"
    }

    // Copy only if the release location isn't empty
    onlyIf {
        return project.release_location != "."
    }
}
