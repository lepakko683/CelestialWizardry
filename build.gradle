/**
 * CelestialWizardry
 * Master build file
 *
 * @author PizzAna
 */

buildscript {

    // Add dependencies for the build script
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
    }
}

// Add dependency repositories
repositories {

}

apply plugin: 'maven'
apply plugin: 'forge'

// http://maven.apache.org/guides/mini/guide-naming-conventions.html
group 'celestialwizardry'

// The name used in final archive artifacts
archivesBaseName = "CelestialWizardry"

// The main property file
ext.configFile = file "build.properties"

// Load the main property file. It shall from now be referenced as simply config or project.config
configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

// Add code dependencies
dependencies {
    /**
     * You may put jars on which you depend on in ./libs
     * or you may define them like so:
     *
     * compile "some.group:artifact:version:classifier"
     * compile "some.group:artifact:version"
     *
     * Real examples:
     *
     * compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // Adds BuildCraft to the development environment
     * compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // Adds ejml to the development environment
     *
     * For more info:
     *
     * http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
     * http://www.gradle.org/docs/current/userguide/dependency_management.html
     */
}

// Finds and sets version data
task buildInfo {

    def cmd = "git rev-parse --short HEAD"
    def proc = cmd.execute()
    proc.waitFor()
    if (proc.exitValue() == 0)
    {
        ext.revision = proc.text.trim()
    }
    else
    {
        ext.revision = "NULL"
    }

    if (System.getenv().BUILD_NUMBER != null)
    {
        ext.build_number = "${System.getenv().BUILD_NUMBER}"
    }
    else
    {
        ext.build_number = "${project.buildInfo.revision}"
    }

    println "CelestialWizardry revision ${project.buildInfo.revision} build ${project.buildInfo.build_number}"
}

version = "${config.mod_version}.${project.buildInfo.build_number}"

// Print out the minecraft forge version
println config.mc_version + "-" + config.forge_version

// Setup the forge minecraft plugin data. Specify the preferred forge/minecraft version and assets directory here
minecraft {
    version = config.mc_version + "-" + config.forge_version
    assetDir = 'run/assets'

    replaceIn "reference/Version.java"
    replace "@VERSION@", project.version

    replaceIn "reference/Reference.java"
    if (project.hasProperty("cw_signature"))
    {
        replace "@FINGERPRINT@", project.cw_signature
    }
}

processResources {

    // This will ensure that this task is redone when the versions or Baubles root directory change.
    inputs.property "version", project.version
    inputs.property "mc_version", config.mc_version
    inputs.property "baubles_version", config.baubles_version
    inputs.property "baubles_root", config.baubles_root

    // Exclude .xcf files since they are for development only
    exclude '**/*.xcf'

    // Replace properties in info files
    from(sourceSets.main.resources.srcDirs) {

        // Include only info files
        include '**/*.info'

        // Replace version, mc_vrsion, baubles_version and baubles_root
        expand 'version': project.version, 'mc_version': config.mc_version,
               'baubles_version': config.baubles_version, 'baubles_root': config.baubles_root
    }

    // Copy everything excluding info files
    from(sourceSets.main.resources.srcDirs) {
        // Exclude info files
        exclude '**/*.info'
    }
}

// Set the version for archive names
version = "${project.minecraft.version}-${project.version}"

// Add custom source sets so gradle takes right sources to api and source archives
sourceSets {
    out {
        java {
            srcDir './build/sources/java/'
        }
        resources {
            srcDir './build/resources/main/'
        }
    }
}

// Set the common manifest for archives
def commonManifest = {
    attributes 'FMLCorePlugin': 'celestialwizardry.codechicken.core.launch.DepLoader'
    attributes 'FMLCorePluginContainsFMLMod': 'true'
}

// Make the universal jar
jar {
    manifest commonManifest
}

// Make the source jar
task sourceJar(type: Jar) {
    from sourceSets.out.allSource
    classifier = "src"
}

// Make the api jar
task apiJar(type: Jar) {
    from(sourceSets.out.allSource) {
        // Include only the api package
        include 'celestialwizardry/api/*'
    }
    classifier = "api"
}

// Make the deobsfucated developer jar
task deobfJar(type: Jar) {
    from sourceSets.main.output
    classifier = "deobf"
    manifest commonManifest
}

// Tell the archive system about the extra archives
artifacts {
    archives apiJar
    archives deobfJar
    archives sourceJar
}

ext.baubles_file = "Baubles-deobf-${config.mc_version}-${config.baubles_version}.jar"
ext.baubles_url = "${config.baubles_root}${project.baubles_file}"
ext.baubles_dir = "./libs/${project.baubles_file}"
ext.libs_dir = "./libs/"

// Download baubles from azanor's mirror and place it to libs folder
task getBaubles(dependsOn: "extractUserDev") {
    doLast {
        ant.mkdir(dir: project.libs_dir)
        ant.get(src: project.baubles_url, dest: project.baubles_dir)
    }
}

// Make getting baubles dependency for setting up the workspace
tasks.setupDevWorkspace.dependsOn project.tasks.getBaubles
tasks.setupDecompWorkspace.dependsOn project.tasks.getBaubles

// Keystore location
if (!project.hasProperty("keystore_location"))
{
    ext.keystore_location = "."
}

// Keystore alias
if (!project.hasProperty("cw_keystore_alias"))
{
    ext.ee3_keystore_alias = ""
}

// Keystore password
if (!project.hasProperty("keystore_password"))
{
    ext.keystore_password = ""
}

task signJar(dependsOn: "build") {
    inputs.file jar.getArchivePath()
    inputs.file keystore_location
    inputs.property "cw_keystore_alias", cw_keystore_alias
    inputs.property "keystore_password", keystore_password
    outputs.file jar.getArchivePath()

    // Only sign if the keystore exists
    onlyIf {
        return keystore_location != "."
    }

    // Sign the jar
    doLast {
        ant.signjar(
                destDir: jar.destinationDir,
                jar: jar.getArchivePath(),
                keystore: keystore_location,
                alias: cw_keystore_alias,
                storepass: keystore_password
        )
    }
}

import net.minecraftforge.gradle.delayed.DelayedFile
import net.minecraftforge.gradle.delayed.DelayedString
import net.minecraftforge.gradle.tasks.dev.ChangelogTask

task createChangelog(type: ChangelogTask) {

    if (("${System.getenv().JOB_NAME}" != null) && project.hasProperty("jenkins_server") &&
            project.hasProperty("jenkins_password"))
    {
        def jobName = "${System.getenv().JOB_NAME}"
        def buildNumber = "${System.getenv().BUILD_NUMBER}"

        setServerRoot(new DelayedString(project, project.jenkins_server))
        setJobName(new DelayedString(project, jobName.toString()))
        setAuthName(new DelayedString(project, project.jenkins_user))
        setAuthPassword(new DelayedString(project, project.jenkins_password))
        setTargetBuild({buildNumber.toString()});
        setOutput(
                new DelayedFile(project, 'build/libs/' + project.getName() + '-' + project.version + '-changelog.txt'));
    }

    onlyIf {
        return (("${System.getenv().JOB_NAME}" != null) && project.hasProperty("jenkins_server") &&
                project.hasProperty("jenkins_password"))
    }
}

tasks.build.dependsOn('createChangelog')

// Configure an upload task
uploadArchives {
    repositories {
        if (project.hasProperty("maven"))
        {
            mavenDeployer {
                logger.info("Deploying to maven repository")

                repository(url: project.maven)

                pom {
                    groupId = project.group
                    version = project.version
                    artifactId = project.archivesBaseName

                    project {
                        name project.archivesBaseName
                        packaging 'jar'
                        description 'CelestialWizardry'
                        url 'https://github.com/PizzAna/CelestialWizardry'

                        scm {
                            url 'https://github.com/PizzAna/CelestialWizardry'
                            connection 'scm:git:git://github.com/PizzAna/CelestialWizardry.git'
                            developerConnection 'scm:git:git@github.com:PizzAna/CelestialWizardry.git'
                        }

                        issueManagement {
                            system 'github'
                            url 'https://github.com/PizzAna/CelestialWizardry/issues'
                        }

                        licenses {
                            license {
                                name 'GNU GENERAL PUBLIC LICENSE v2'
                                url 'http://www.gnu.org/licenses/gpl-2.0.html'
                                distribution 'repo'
                            }
                        }

                        developers {
                            developer {
                                id 'PizzAna'
                                name 'PizzAna'
                                roles {role 'developer'}
                            }
                            developer {
                                id 'le683'
                                name 'Okkapel'
                                roles {role 'developer'}
                            }
                        }
                    }
                }

                repository(url: project.maven_mirror)

                pom {
                    groupId = project.group
                    version = project.version
                    artifactId = project.archivesBaseName

                    project {
                        name project.archivesBaseName
                        packaging 'jar'
                        description 'CelestialWizardry'
                        url 'https://github.com/PizzAna/CelestialWizardry'

                        scm {
                            url 'https://github.com/PizzAna/CelestialWizardry'
                            connection 'scm:git:git://github.com/PizzAna/CelestialWizardry.git'
                            developerConnection 'scm:git:git@github.com:PizzAna/CelestialWizardry.git'
                        }

                        issueManagement {
                            system 'github'
                            url 'https://github.com/PizzAna/CelestialWizardry/issues'
                        }

                        licenses {
                            license {
                                name 'GNU GENERAL PUBLIC LICENSE v2'
                                url 'http://www.gnu.org/licenses/gpl-2.0.html'
                                distribution 'repo'
                            }
                        }

                        developers {
                            developer {
                                id 'PizzAna'
                                name 'PizzAna'
                                roles {role 'developer'}
                            }
                            developer {
                                id 'le683'
                                name 'Okkapel'
                                roles {role 'developer'}
                            }
                        }
                    }
                }
            }
        }
        else
        {
            add project.repositories.mavenLocal()
        }
    }
}

// Uploading archives should be after signing the jar
uploadArchives.shouldRunAfter tasks.signJar

// Mostly a dummy task for building the jars for official release
task release {
    println "Release the savage!"
}

// Make the release task dependant on signing the jar so it builds the mod when release task is called
tasks.release.dependsOn project.tasks.signJar

// Make the release task dependant on deploying the jar so it uploads archives when release task is called
tasks.release.dependsOn uploadArchives
