/**
 * CelestialWizardry
 * Master build file
 *
 * @author PizzAna
 */

buildscript {

    // Add dependencies for the build script
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2-SNAPSHOT'
    }
}

// Add dependency repositories
repositories {
    maven {
        name = "chickenbones"
        url = "http://chickenbones.net/maven/"
    }
    maven {
        name = "celestialwizardry"
        url = "http://localhost/maven/"
    }
}

apply plugin: 'maven'
apply plugin: 'forge'

// http://maven.apache.org/guides/mini/guide-naming-conventions.html
group 'celestialwizardry'

// The name used in final archive artifacts
archivesBaseName = "CelestialWizardry"

// The main property file
ext.configFile = file "build.properties"

// Load the main property file. It shall from now be referenced as simply config or project.config
configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

// Add code dependencies
dependencies {
    /**
     * You may put jars on which you depend on in ./libs
     * or you may define them like so:
     *
     * compile "some.group:artifact:version:classifier"
     * compile "some.group:artifact:version"
     *
     * Real examples:
     *
     * compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // Adds BuildCraft to the development environment
     * compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // Adds ejml to the development environment
     *
     * For more info:
     *
     * http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
     * http://www.gradle.org/docs/current/userguide/dependency_management.html
     */
}

// Find and set the version info from git for the build
task buildInfo {

    // Run the command to get the git revision
    def cmd = "git rev-parse --short HEAD"
    def run = cmd.execute()
    run.waitFor()

    ext.revision = "NULL"

    // Set the revision depending on the result of command execution
    if (run.exitValue() == 0)
    {
        revision = run.text.trim()
    }
    else
    {
        revision = "NULL"
    }

    ext.buildNum = "0"

    if (System.getenv().BUILD_NUMBER != null)
    {
        build_number = "${System.getenv().BUILD_NUMBER}"
    }
    else
    {
        build_number = "${project.tasks.buildInfo.revision}"
    }
}

ext.artifact_version = 'NFG'

if (System.getenv().ARTIFACT_VERSION == null)
{
    artifact_version = "${config.mod_version}.${project.tasks.buildInfo.buildNum}"
}
// TODO else maybe
if (System.getenv().ARTIFACT_VERSION != null)
{
    artifact_version = "${System.getenv().ARTIFACT_VERSION}"
}

version = "${artifact_version}"

// Print out the minecraft forge version
println config.mc_version + "-" + config.forge_version

// Setup the forge minecraft plugin data. Specify the preferred forge/minecraft version and assets directory here
minecraft {
    version = config.mc_version + "-" + config.forge_version
    assetDir = 'run/assets'

    replaceIn "reference/Reference.java"
    if (project.hasProperty("CelestialWizardry.release") &&
            new File(project.property("CelestialWizardry.release")).exists())
    {

        // Load the private property file if one is found
        Properties props = new Properties()
        props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

        replace "@FINGERPRINT@", props['signature']
    }

    replaceIn "reference/Version.java"
    replace "@VERSION@", project.version
}

processResources {

    // This will ensure that this task is redone when the versions or Baubles root directory change.
    inputs.property "version", project.version
    inputs.property "mc_version", config.mc_version
    inputs.property "baubles_version", config.baubles_version
    inputs.property "baubles_root", config.baubles_root

    // Exclude .xcf files since they are not part of the mod
    exclude '**/*.xcf'

    // Replace properties in info files
    from(sourceSets.main.resources.srcDirs) {

        // Include only info files
        include '*.info'

        // Replace version, mc_vrsion, baubles_version and baubles_root
        expand 'version': project.version, 'mc_version': config.mc_version,
               'baubles_version': config.baubles_version, 'baubles_root': config.baubles_root
    }

    // Copy everything excluding info files
    from(sourceSets.main.resources.srcDirs) {
        // Exclude info files
        exclude '*.info'
    }
}

// Set the version for archive names
version = "${project.minecraft.version}-${artifact_version}"

// Add custom source sets so gradle takes right sources to api and source archives
sourceSets {
    out {
        java {
            srcDir './build/sources/java/'
        }
        resources {
            srcDir './build/resources/main/'
        }
    }
}

// Set the common manifest for archives
def commonManifest = {
    attributes 'FMLCorePlugin': 'celestialwizardry.codechicken.core.launch.DepLoader'
    attributes 'FMLCorePluginContainsFMLMod': 'true'
}

// Make the universal jar
jar {
    manifest commonManifest
}

// Make the source jar
task sourceJar(type: Jar) {
    from sourceSets.out.allSource
    classifier = "src"
}

// Make the api jar
task apiJar(type: Jar) {
    from(sourceSets.out.allSource) {
        // Include only the api package
        include 'celestialwizardry/api/*'
    }
    classifier = "api"
}

// Make the deobsfucated developer jar
task deobfJar(type: Jar) {
    from sourceSets.main.output
    classifier = "deobf"
    manifest commonManifest
}

// Tell the archive system about the extra archives
artifacts {
    archives apiJar
    archives deobfJar
    archives sourceJar
}

// Make the api and sources archives after compiled archive to make sure they have correct constant values
tasks.apiJar.shouldRunAfter project.tasks.deobfJar
tasks.sourceJar.shouldRunAfter project.tasks.deobfJar

ext.baubles_file = "Baubles-deobf-${config.mc_version}-${config.baubles_version}.jar"
ext.baubles_url = "${config.baubles_root}${project.baubles_file}"
ext.baubles_dir = "./libs/${project.baubles_file}"

// Download baubles from azanor's mirror and place it to libs folder
task getBaubles(dependsOn: "extractUserDev") {
    doLast {
        ant.mkdir(dir: project.baubles_dir)
        ant.get(src: project.baubles_url, dest: project.baubles_dir)
    }
}

// Make getting baubles dependency for setting up the workspace
tasks.setupDevWorkspace.dependsOn project.tasks.getBaubles
tasks.setupDecompWorkspace.dependsOn project.tasks.getBaubles

// Set the information for signing the jar
if (project.hasProperty("CelestialWizardry.release") &&
        new File(project.property("CelestialWizardry.release")).exists())
{

    // Load the private property file if one is found
    Properties props = new Properties()
    props.load(new FileInputStream(file(project.property("CelestialWizardry.release"))))

    ext.keystore_location = file(props['keystore_location'])
    ext.keystore_user_alias = props['keystore_alias']
    ext.keystore_user_password = props['keystore_password']

    println "Valid jar signing properties found"
}
else
{
    ext.keystore_location = "."
    ext.keystore_user_alias = ""
    ext.keystore_user_password = ""
}

// Sign the final jar
task signJar {

    // This will ensure that this task is redone when the some of these properties change.
    inputs.file jar.getArchivePath()
    inputs.file keystore_location
    inputs.property "keystore_user_alias", keystore_user_alias
    inputs.property "keystore_user_password", keystore_user_password
    outputs.file jar.getArchivePath()

    // Only sign the jar if the keystore exists
    onlyIf {
        return keystore_location != "."
    }

    println "Path to archive: " + jar.getArchivePath()

    // Sign the jar
    doLast {
        ant.signjar(
                destDir: jar.destinationDir,
                jar: jar.getArchivePath(),
                keystore: keystore_location,
                alias: keystore_user_alias,
                storepass: keystore_user_password,
                keypass: keystore_user_password
        )
    }
}

// Make signing the to depend on building the jar
tasks.signJar.dependsOn tasks.build

// Configure an upload task
uploadArchives {
    if (System.getenv().MAVEN != null)
    {
        repositories {
            logger.info('Publishing to maven repo')

            mavenDeployer {
                repository(url: "file://${System.getenv("MAVEN")}")
            }
        }
    }
}

// Uploading archives should be after signing the jar
uploadArchives.shouldRunAfter tasks.signJar

// Mostly a dummy task for building the jars for official release
task release {
    println "Release the savage!"
}

// Make the release task dependant on signing the jar so it builds the mod when release task is called
tasks.release.dependsOn project.tasks.signJar

// Make the release task dependant on deploying the jar so it uploads archives when release task is called
tasks.release.dependsOn uploadArchives
